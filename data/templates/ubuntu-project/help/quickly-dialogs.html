<HTML>
<HEAD>
<TITLE>Quickly Tutorial Part 2</TITLE>
<STYLE>
img
{
    display: block;
    width:668px;
    padding-top:10px;
}
p
{
    width: 800px;
}

</STYLE>
</HEAD>
<BODY>
<H1>Introduction to Part 2</H1>
<P>In part 1, we created an application that can read and write text files, and persist them in the couchdb backend. However, the application has a hideous usability flaw, in the text box for specifying titles when saving and opening files is very confusing. In part 2, we'll fix thay by adding a save and an open dialog.

</P>

<H1>Creating a Quickly Dialog</H1>
<H2>Creating the Empty Dialog</H2>
<P>It's simple to add an empty, but working dialog to your project. Simply specify the name of the new dialog, and it will be added automatically. Assuming that you are in the jotty project directory:</P>
<DIV class="termnial"><TEXTAREA rows = "1" cols="80">
$quickly dialog save
</TEXTAREA></DIV>
<P>This will add the dialog to your project.</P>
<H2>Editing the New Dialog</H2>
<P>To edit the UI for the dialog, you'll need to load it into Glade again. If you already have an instance of glade running, you might want to go ahead and close it first, as it may get confusing if you have more than one open at a time. After closing glade, simply open it again:</P>
<DIV class="termnial"><TEXTAREA rows = "1" cols="80">
$quickly glade
</TEXTAREA></DIV>
<P>Then use the project menu to switch to newly created SaveDialog.ui file.</P>
<IMG SRC="./images/glade17.png" ALT="save dialog ready to edit" />
<P>Then add some widgets for the UI. Start with a Vertical Box (VBox) with two items. Put label in the top, and an HBox in the bottom slot. In the HBox, add a label and an edit widget, just like you did for JottyWindow in part 1. Set the padding and expand properties as well.</P>
<IMG SRC="./images/glade18.png" ALT="save dialog all edited" />
<H2>Code the Dialog</H2>
<P>You can use the "quickly edit" command to open the SaveDialoy.py file. This dialog needs very little additional code to work. Essentially, you just need a way to retrieve the string specified by the user. We'll add a qiuck accessor method for this:</P>
<DIV class="code"><TEXTAREA rows="2" cols="80">
    @property
    def title_text(self):
        return self.builder.get_object("entry1").get_text()
</TEXTAREA></DIV>
<P>We don't need to write any code for the Ok and Cancel buttons, as they were automatically hooked up by quickly when it created the dialog.</P>
<P>Before we go on to invoking the dialog, delete HBox from JottyWindow that holds the text entry and label, as we won't be needing those.</P>
<IMG SRC="./images/glade19.png" ALT="text entry now deleted" />

<H1>Calling the Save Dialog</H1>
<P>To use the dialog in JottyWindow, we need to follow these steps:</P>
<OL>
<LI>Import SaveDialog in JottyWindow</LI>
<LI>In the save_file function, create an instance of SaveDialog</LI>
<LI>Run the Dialog</LI>
<LI>Get the String</LI>
<LI>Destroy the dialog</LI>
</OL>
<H2>Importing the SaveDialog</H2>
Add the SaveDialog to the list of imported modules at the top of the, so it looks like this:
<DIV class="code"><TEXTAREA rows="1" cols="80">
from jotty import AboutJottyDialog, PreferencesJottyDialog, SaveDialog
</TEXTAREA></DIV>

<H2>Create an instance of the dialog and run it</H2>
<P>When the user chooses Save, we want to open the SaveDialog and collect the title of the note from the user. So we need to modify our save_file function.</P>

<P>To create an instance of the dialog, use the NewSaveDialog() function in the SaveDialog module. It's important that you don't create an instance of SaveDialog directly, as it won't have a chance to load up it's UI that way, and it won't work. So whenever you use a quickly dialog, do it like this:</P>
<DIV class="code"><TEXTAREA rows="1" cols="80">
        saver = SaveDialog.NewSaveDialog()
</TEXTAREA></DIV>
<P>To make the dialog appear, simply use the run() method. However, we want to check the result, so we'll need to store that in a variable. After it runs, we want to collect the string from the user, like this:</P>
<DIV class="code"><TEXTAREA rows="2" cols="80">
        result = saver.run()
        title = saver.title_text
</TEXTAREA></DIV>

<H2>Clean up the dialog</H2>
<P>We need to tell the dialog to not show itself anymore. We could call saver.hide() to make it hide, but since we don't need it hanging around, we'll just destroy it. Before we go on, though, we need to ensure that the user actually wants to save, so if we didn't get the Ok result, we should just return out of the function:</P>
<DIV class="code"><TEXTAREA rows="2" cols="80">
        saver.destroy()
        if result != gtk.RESPONSE_OK:
            return
</TEXTAREA></DIV>

<P>Since we're now getting the title from the dialog instead of the text entry, we should delete the line of the code that sents it from entry1. So except for the addition of the dialog code, the save_file function looks pretty much the same as it did in part 1:</P>

<DIV class="code"><TEXTAREA rows="32" cols="80">
    def save_file(self, widget, data=None):
        #get the titel from the user
        saver = SaveDialog.NewSaveDialog()
        result = saver.run()
        title = saver.title_text

        saver.destroy()
        if result != gtk.RESPONSE_OK:
            return

        #get the text to save
        buff = self.builder.get_object("textview1").get_buffer()
        start_iter = buff.get_start_iter()
        end_iter = buff.get_end_iter()
        text = buff.get_text(start_iter,end_iter)

        #get all the records
        record_type = "http://wiki.ubuntu.com/Quickly/JottyDoc"
        results = self.database.get_records(record_type = record_type, 
                                            create_view = True)

        #update a record that has the same title
        for result in results:
            record = result.value
            if record["title"] == title:
                key = result.key
                self.database.update_fields(key, {"text":text})
                return
        
        #if no records had the title, create it  
        new_rec = Record({"record_type":record_type ,
                            "title":title, "text":text})
        self.database.put_record(new_rec)
</TEXTAREA></DIV>

Now when we choose save, we get the SaveDialog instead:
<IMG SRC="./images/application4_5.png" ALT="save file dialog works much better" />

<H1>Creating a Dialog with a CouchGrid</H1>
<P>
We'll use a similar approach in the Open dialog that we did with Save. However, there is one big difference, we want to provide the user with a list of documents that you could choose to open. We'll use a widget called CouchGrid, which is included in the desktopcouch api for this.
</P>
<H2>Create the Open Dialog</H2>
<DIV class="termnial"><TEXTAREA rows = "1" cols="80">
$quickly dialog open
</TEXTAREA></DIV>
<H2>Editing the New Dialog</H2>
<P>Start out by closing, and then reopening glade again:</P>
<DIV class="termnial"><TEXTAREA rows = "1" cols="80">
$quickly glade
</TEXTAREA></DIV>
<P>Start by adding an HBox and label in the sammer manner as in the Save Dialog above. Leave an empty space in the HBox. We will use code to put the CouchGrid there.</P>
<IMG SRC="./images/glade20.png" ALT="save space for the CouchGrid" />

<H2>Coding the Open Dialog</H2>
<H3>Creating and Adding a CouchGrid</H3>
<P>It just takes a little bit of code to add a CouchGrid to the  dialog. We need to:</P>
<OL>
<LI>Import the CouchGrid class.</LI>
<LI>Create a CouchGrid pointing at the jotty database, and the desired record type.</LI>
<LI>Add the CouchGrid to the dialog.</LI>
</OL>
<H4>Import the CouchGrid class</H4>
<P>CouchGrid is part of the desktopcouch records api, so we import it like this:</P>
<DIV class="code"><TEXTAREA rows="1" cols="80">
from desktopcouch.records.couchgrid import CouchGrid
</TEXTAREA></DIV>
<H4>Create the CouchGrid</H4>
<P>A CouchGrid needs to know three things, the name of the database, the name of the record type to, and the name of the keys to use. "keys" is a list of fields that the widget will display, and by default will also use the same text for the heading of any columns. This set up should be done in the OpenDialog's finish_initalizing function. All this is easily done in code like this:
<DIV class="code"><TEXTAREA rows="4" cols="80">
        database = "jotty"
        keys = ["title"]
        record_type = "http://wiki.ubuntu.com/Quickly/JottyDoc"
        self.couchgrid = CouchGrid(database, record_type=record_type,keys=keys)
</TEXTAREA></DIV>
<H4>Add the CouchGrid to the Dialog</H4>
<P>When we added the HBox to the dialog, we left an open space at the bottom. We'll use this by "packing" the CouchGrid into the HBox. We need to show it as well. So add the following lines to the finish_initializing function as well:
<DIV class="code"><TEXTAREA rows="2" cols="80">
        self.couchgrid.show()
        self.builder.get_object("vbox1").pack_end(self.couchgrid)
</TEXTAREA></DIV>

<H3>Create the get_selection function</H3>
<P>The dialog still needs a bit more code to work. It needs to return the user's selection, if there is one. To do this, we need to ask the CouchGrid what is selected. This is easy using the widgets selected_record_ids function. But the CouchGrid supports multiple selection, so we'll do the following:</P>
<OL>
<LI>Use a decorator to define the function as a property accessor.</LI>
<LI>Get all the selected record ids.</LI>
<LI>If none are selected, return None.</LI>
<LI>Pick the first one and return it.</LI>
</OL>
<P>So the function to add to OpenDialog looks like this:</P>
<DIV class="code"><TEXTAREA rows="7" cols="80">
    @property
    def selected_record_id(self):
        ids = self.couchgrid.selected_record_ids
        if len(ids) < 1:
            return None
        else:
            return ids[0]
</TEXTAREA></DIV>
<H1>Using the Open Dialog</H1>
<P>Now we want to use the Open Dialog in the JottyWindow open_file function. To use it,we'll follow these steps:</P>
<OL>
<LI>Import OpenDialog in JottyWindow</LI>
<LI>In the open_file function, create an instance of OpenDialog</LI>
<LI>Run the Dialog</LI>
<LI>Get the id for the selected title.</LI>
<LI>Destroy the dialog</LI>
<LI>Check the response before proceeding</LI>
<LI>Use the id to get the record from CouchDB</LI>
<LI>Update the UI</LI>
</OL>

<H2>Import OpenDialog</H2>
<P>Just like the SaveDialog, add the import line to the list of imports:</P>
<DIV class="code"><TEXTAREA rows="1" cols="80">
from jotty import AboutJottyDialog, PreferencesJottyDialog, SaveDialog, OpenDialog
</TEXTAREA></DIV>

<H2>Create an instance of the dialog and run it</H2>
<P>So now we're ready to call the dialog from the JottyWindow's open_file function. Creating the OpenDialog is exactly the same as creating the SaveDialog, except we also want to tell it to load the titles before we run it:</P>
<DIV class="code"><TEXTAREA rows="3" cols="80">
        opener = OpenDialog.NewOpenDialog()
        result = opener.run()
</TEXTAREA></DIV>

<H2>Get the id for the selected title</H2>
<P>Now use the get_selection function to retrieve the title and text from the dialog. Don't forget to check the response type before going on.</P>
<DIV class="code"><TEXTAREA rows="5" cols="80">
        id = opener.selected_record_id
        opener.destroy()

        if result != gtk.RESPONSE_OK or text == None:
            return
</TEXTAREA></DIV>

<H2>Get the ID for the selected title</H2>
<P>This merely involves using the property that we created for th OpenDialog:</P>
<DIV class="code"><TEXTAREA rows="1" cols="80">
        rec_id = opener.selected_record_id
</TEXTAREA></DIV>

<H2>Use the id to get the record from CouchDB</H2>
<P>If nothing was selected, we'll just return. Otherwise, we'll retrieve the record from CouchDB and pull out the text for the document:</P>
<DIV class="code"><TEXTAREA rows="5" cols="80">
        #get the record from CouchDB and extract the text
        if rec_id == None:
            return
        record = self.database.get_record(rec_id)
        text = record["text"]
</TEXTAREA></DIV>

<H2>Update the UI</H2>
<P>Now just put the text into the texview:</P>
<DIV class="code"><TEXTAREA rows="3" cols="80">
        #set the UI to display the string
        buff = self.builder.get_object("textview1").get_buffer()
        buff.set_text(text)
</TEXTAREA></DIV>
<P>That's all there is to it. So the whole open_file function looks like this:</P>
<DIV class="code"><TEXTAREA rows="21" cols="80">
    def open_file(self, widget, data=None):
        #run the open dialog
        opener = OpenDialog.NewOpenDialog()
        result = opener.run()

        #get the record id from the dialog
        rec_id = opener.selected_record_id

        #close the dialog, and check whether to proceed
        opener.destroy()
        if result != gtk.RESPONSE_OK:
            return

        #get the record from CouchDB and extract the text
        if rec_id == None:
            return
        record = self.database.get_record(rec_id)
        text = record["text"]

        #set the UI to display the string
        buff = self.builder.get_object("textview1").get_buffer()
        buff.set_text(text)
</TEXTAREA></DIV>
<P>Now users get a nice open dialog:</P>
<IMG SRC="./images/application5.png" ALT="open dialog works much better" />


<H1>Finsihing the Application</H1>
<P>Now opening a saved document is much more intuitive.</P>
<IMG SRC="./images/application6.png" ALT="open file dialog works much better" />
<P>However, the application is not complete. There are a few things left for you to do:</P>
<UL>
<LI>Set the title of the JottyWindow to display the note title. Try self.set_text(title).</LI>
<LI>The Save command works more like "Save As". The application probably shouldn't pop up a SaveDialog every time you want to save. If it's already been saved, you probably just want to save it, but use a SaveDialog when the user choose Save As, or is saving a document for the first time.</LI>
<LI>The OpenDialog should probably return when the user double clicks on an item in the list. Try connecting to the "select-cursor-row" signal on the TreeView, and calling self.response(gtk.RESPONSE_OK) in the handler.</LI>
<LI>Perhaps the Ok button in the OpenDialog should be disabled if nothing is selected. Try setting the "sensitivity" in Glade, and the set_sensitive function for the Ok button.</LI>
<LI>It would be more consistent for the Open and Close dialogs to have "Open" and "Close" for buttons instead of "Ok". You can set a different type in the properties window in Glade.</LI>
<LI>Loading every document into the open dialog is probably a bit inefficient. Perhaps storing the document id and using that to retrieve the document would be a better implementation.</LI>
</UL>
</BODY>
