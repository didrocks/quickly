<HTML>
<HEAD>
<TITLE>Quickly Tutorial Part 1</TITLE>
<STYLE>
img
{
    display: block;
    width:668px;
    padding-top:10px;
}
p
{
    width: 800px;
}

</STYLE>
</HEAD>
<BODY>
<H1>Introduction to Part 1</H1>
<P>This part 1 of the Quickly tutorial. This part is will introduce some key quickly commands, editing a user interface in Glade, and editing code in Gedit. This part of the tutorial will familiarize you with these three tools, and how they work together with python and pygtk so that you can quickly build applications.</P>


<H1>Creating a Quickly Project</H1>
<H2>Creating the Empty Project</H2>
<P>Creating an empty but working program couldn't be simpler. First, open a terminal window to type commands into. When it's open, type the command:</P>
<DIV class="termnial"><TEXTAREA rows = "1" cols="80">
$quickly create ubuntu-application jotty
</TEXTAREA></DIV>
<IMG SRC="./images/terminal1.png" ALT="type 'quickly create ubuntu-application jotty' into terminal" />
<P>This will create a jotty sub directory containing a complete directory tree and files for an empty python application. The command finishes by running the newly created empty application.</P>
<IMG SRC="./images/application1.png" ALT="The command finishes by running the empty application." />

<H2>Testing the Empty Application</H2>
<P>They are populated and set up, and you can resize the window. Notice that quickly inferred that the application title is "Jotty". Only a few of menu items do anything in the empty application, Help->About, Edit->Preferences, and File->Quit.</P>
<IMG SRC="./images/application2.png" ALT="The menus are populated and set up." />

<H2>Running the Application</H2>
<P>Close the application by closing the window or using the Quit command. Since the empty application isn't installed into Ubuntu yet, you can't start the application from the application menu yet. To start the applicaton, use the terminal to first cd into the new subdirectory, and then use "quickly run" to start the program.</P>
<DIV class="termnial"><TEXTAREA rows = "1" cols="80">
$cd jotty
jottyt$quickly run
</TEXTAREA></DIV>
<IMG SRC="./images/terminal3.png" ALT="run the empty application from the terminal" />

<H1>Editing an Application</H1>
<H2>Edit the User Interface in Glade</H2>
<P>Quickly programs use Glade to edit the user interface. Start Glade with quickly in order to set up Glade for editing the empty applicaton. Don't start glade directly, or it won't load the necessary catalogue files for editing the classes that were automaticaly generated by quickly.</P>
<DIV class="termnial"><TEXTAREA rows = "1" cols="80">
jotty$ quickly design
</TEXTAREA></DIV>
<IMG SRC="./images/terminal4.png" ALT="start glade with the 'quickly glade' command " />
<P>Glade will open with the project loaded up and ready to edit.</P>
<IMG SRC="./images/glade1.png" ALT="glade loads the project " />
<P>Use the Project Menu to choose "JottytWindow.ui" for editing.</P>
<IMG SRC="./images/glade2.png" ALT="choose JottyWindow.ui from the project menu " />
<P>We want to create a text area for typing into. There are some default Widgets added to the Window. We won't need these so we'll start with deleting them. Click on the label, and press delete, and it will disappear from the window.</P>
<IMG SRC="./images/glade3.png" ALT="select the label" />

<IMG SRC="./images/glade4.png" ALT="delete the label from the window" />
<P>Do the same with the image widget. This leave us two free slots.</P>
<IMG SRC="./images/glade6.png" ALT="two empty slots in the window" />
<P>We'll use the bottom slot to add a TextView widget for the user to type into. In the toolbox, click on the TextView widget. Then click in the empty slot.</P>
<IMG SRC="./images/glade7.png" ALT="click on the text view widget" />

<P>Make sure you save the file in Glade, or your changes won't take! Then run the application from terminal again. The window now has a place where the user can type.</P>
<IMG SRC="./images/application3.png" ALT="the applicaton permits typing" />

<P>Now we'll add the entry field for the title, and also a label for it. We'll use the top empty slot for that. First, click on Horizontal Box (HBox) from the "Containers" section of the pallette, and then click on the top slot. A dialog box will open, tell it that you want two items.</P>
<IMG SRC="./images/glade8.png" ALT="tell the hbox you want two items" />
<P>The HBox is a container that arranges it's children horizontally. Add a label to the empty left hand box, and a Text Entry to the right hand one.</P>
<IMG SRC="./images/glade9.png" ALT="text entry is added" />

<P>Before going on, let's clean up the UI just a tad here. Select the new HBox from the treeview in the inspector window. Then go to the Packing tab, and set Expand and Fill to "No".</P>
<IMG SRC="./images/glade10.png" ALT="no expand and fill" />

<P>Go to the General tab, and set spacing to 5.</P>
<IMG SRC="./images/glade11.png" ALT="spacing is 5" />

<P>Select the label. On the general tab, set "Label" to "Name:". Set expand and fill to "no" for the label, but keep it "yes" for the entry. Set the padding for both to 5 (also on the Packing tab).</P>
<IMG SRC="./images/glade12.png" ALT="glade all cleaned up" />

<H2>Add the Save, Open, and New Features</H2>
<P>After the user types something, they may want to save it. A File->Save menu item was automatically created when the empty applicaton was created, but it's not hooked up to any code. To make Save work, we need tell the menu item what function to call, and then create a function to actually do the saving.</P>

<H3>Set the Signal Handler in Glade</H3>
<P>To tell the menu item what function to call. If glade is not still open, open up the application in glade:</P>
<DIV class="termnial"><TEXTAREA rows = "1" cols="80">
jotty$ quickly design
</TEXTAREA></DIV>

<P>Click on the file menu, and the menu opens as if the application were running.</P>
<IMG SRC="./images/glade13.png" ALT="choose the menu item" />

<P>Choose the Save menu item, and it will be selected in Glade.</P>
<IMG SRC="./images/glade14.png" ALT="the menu item is selcted in glade" />

<P>Then choose the "Signals" tab of the properties window.</P>
<IMG SRC="./images/glade15.png" ALT="signals tab in glade" />
<P>In pygtk, menu items are "activated" when a user chooses the item from the menu.  Since we want a function to run when the user chooses Save, we want to specify a function to respond to the activate signal from the menu item. We'll call the function "save_file". Simply type the function name into the box for the activate signal.Make sure to save the glade file.</P>
<IMG SRC="./images/glade16.png" ALT="activate signal set to 'save_file'" />
<P>Note that you will need to setup the "open_file" signal and the "new_file" signal as well when you get to those functions later.</P>

<H2>Edit the Code in Gedit</H2>
<H3>Set Up Tabs Correctly</H3>
<P>Note a major gotcha here. In python spaces and tabs are totally different, but they look just the same in an editor. So being indented one tab stop is not the same as being indented four spaces, even though they might look the same. And indentation level is very important in python. You will get a lot of errors if you mix tab indentation with space indentation. Your generated project follows the python standard of using four spaces for each indentation level. So you'll either have to hit the space bar four time every time you indent, or set up your editor to use the right number of spaces for tabs.</P>
<P>The upshot is that you should take a moment to set up your Gedit (or whatever editor you are using) to use spaces for tabs. In Gedit, select Preferences from the Edit menu, and choose the Editor tab. Then set Tab width to 4, and turn on "Insert spaces instead of tabs". Your preferences should look like this:</P>
<IMG SRC="./images/gedit2.png" ALT="python files ready to edit" />

<H3>Create the Save File Signal Handler</H3>
<P>Now you're ready to write some code. Of course just telling the glade file what signal to emit won't make the file actually save, because we haven't created the "save_file" function yet. The code for JottyWindow is stored in the file  jotty. jotty is a special python file that is the entry point for your application. Other python files in your application have the ".py" suffix.</P>

<P>Use the quickly edit command to start editing your code files:</P>
<DIV class="termnial"><TEXTAREA rows = "1" cols="80">
jotty$ quickly edit
</TEXTAREA></DIV>
<P>This will open the default Ubuntu text editor "Gedit" with any python files in the python directory.</P>
<IMG SRC="./images/gedit1.png" ALT="python files ready to edit" />


<P>JottyWindow.ui is now expecting to find a function JottyWindow.save_file(), so we simply add one to the JottyWindow class in the jotty file right under the on_destroy funtion.:</P>
<DIV class="code"><TEXTAREA rows="3" cols="80">
    def save_file(self, widget, data=None):
        print "save"
</TEXTAREA></DIV>
<P>This will print the word "save" to the terminal when run. The method signature is the standard signature expected in a signal handler. If you are new to python, be sure to copy the indentations exactly, as the indentation level is very important in python.</P>

<P>Save the file, and run it again:</P>
<DIV class="termnial"><TEXTAREA rows = "2" cols="80">
jotty$ quickly run
</TEXTAREA></DIV>
<P>Choose "File->Save" from the menu, and you'll see the word "save" printing out interminal. That's all there is to hookig up the functions!</P>
<IMG SRC="./images/application3_5.png" ALT="'save' gets printed to the terminal" />

<H3>Implementing Save</H3>
<P>Now we'll write a little code in the signal handler to actually save the text. Because we want it to be easy for users to do things like syncronize their Jotty documents between computers, back it up, etc... we'll use couchdb as our backend, and we'll use desktopcouch for our api. Note that if you are not interested in learning about how to save to and read from couchdb, you can just snipe the code.

Mostly likely you already have everything you need installed when you installed quickly. But, you may need to install couchdb, desktopcouch, and the desktopcouch records api. The fastest way to do this is from the terminal:</P>
<DIV class="termnial"><TEXTAREA rows = "1" cols="80">
$sudo apt-get install python-desktopcouch-records
</TEXTAREA></DIV>

<P>This will install the api, and everything you need for the api to run. After desktopcouch  is installed, you can write the code. The code will do the following:</P>
<OL>
<LI>Import the stuff you'll need from desktopcouch.</LI>
<LI>Get a reference to the couchdb database to save into.</LI>
<LI>Get the title of the document and the text from the user interface.</LI>
<LI>Check if there is already a document with the same title, and if so overwrite it.</LI>
<LI>If there is not a document already, create one.</LI>
</OL>

<H4>Import the stuff you'll need from python-desktopcouch-records.</H4>
<P>Add these import statements along with the other imports to the top of the jotty file:</P>
<DIV class="code"><TEXTAREA rows="3" cols="80">
from desktopcouch.records.server import CouchDatabase
from desktopcouch.records.record import Record
</TEXTAREA></DIV>

<H4>Get a Reference to the Database</H4>
<P>Desktopcouch will set up a database for us, or create a new one if it's needed. We'll use "jotty" for the name of the database. Since we want this line to run every time the Jotty Window is created, put it at the end of the finish_initializing function:</P>
<DIV class="code"><TEXTAREA rows="1" cols="80">
        self.database = CouchDatabase("jotty", create=True)
</TEXTAREA></DIV>

<P>Now that we have an instance-wide reference to the database, we'll add code to the save_file function to run whenever the Save command is issued.</P>
<H4>Here's the code to pull the title out of the title entry:</H4>
<DIV class="code"><TEXTAREA rows="2" cols="80">
        #get the title for the note
        title = self.builder.get_object("entry1").get_text()
</TEXTAREA></DIV>

<H4>Here's the code to get pull the text out of the TextView:</H4>
<P>In pygtk, TextView widgets have a text buffer that stores the text. So you ask the TextView for it's TextBuffer, and then you ask the TextBuffer for the text. You use iters to determine from which part of the text buffer you want text. Since we want all the text, it's easy to just get the start and end iters.</P>
<DIV class="code"><TEXTAREA rows="7" cols="80">
    #get the string
    buff = self.builder.get_object("textview1").get_buffer()
    start_iter = buff.get_start_iter()
    end_iter = buff.get_end_iter()

    text = buff.get_text(start_iter,end_iter)
</TEXTAREA></DIV>

<H4>Saving a document to Couchdb</H4>
<P>A record in couch is essentially a python dictionary with some extra key/value pairs to make the database work. So we can save the document to couch like this:</P>
<DIV class="code"><TEXTAREA rows="4" cols="80">
            record_type = "http://wiki.ubuntu.com/Quickly/JottyDoc"
            new_rec = Record({"record_type": record_type,
                                "title":title, "text":text})
            self.database.put(new_rec)
</TEXTAREA></DIV>
<P>The "record_type" field is not strictly required, but among other things, it makes it easy to fetch the documents later. By convention, we use a url to specify the record type. This provides a place for other developers to go to read about the record type. The description only needs to be human readable. Couchdb is not a typed database, so don't expect that the url will have any kind of schema definition or anything. You can use whatever url you want, and put whatever you want at that URL.</P>

<H4>Check for a pre-existing note with the same title</H4>
<P>Before we just write the new document though, we have to take note of the fact that couch will allow you to create as many documents as you want with the same title. We probably don't want this, so we we'll have to write a little code to check if there is already a document in couch with the same title, and if there is, update that document rather than create a new one.</P>
<P>In CouchDB, you don't do a lot of data processing in the database like you would with a relational database. To be most efficient, we could use the desktopcouch API to create a view in CouchDB, but it's probably simplest just to do the necessary processing on the client for now. To do this, we'll use a desktopcouch function to retrieve all of the records of a specified record type.</P>

<P>To find and update documents with a matching title we will:</P>
<OL>
<LI>Retrieve all of the documents with the CouchDatabase.get_records function.</LI>
<LI>Check each of the returned records for a matching title.</LI>
<LI>If there is a match, update the record using the CouchDatabase.update_fields function and return.</LI>
</OL>

<P>This all may sound very weird, but in code, it's not quite so complicated:</P>
<DIV class="code"><TEXTAREA rows="9" cols="80">
        #get all the records
        record_type = "http://wiki.ubuntu.com/Quickly/JottyDoc"
        results = self.database.get_records(record_type = record_type, 
                                            create_view = True)

        #update a record that has the same title
        for result in results:
            document = result.value
            if document["title"] == title:
                key = document["_id"]
                self.database.update_fields(key, {"text":text})
                return

</TEXTAREA></DIV>

<H4>So the whole function should look like this:</H4>
<DIV class="code"><TEXTAREA rows="20" cols="80">
    def save_file(self, widget, data=None):
        #get the title for the note
        title = self.builder.get_object("entry1").get_text()

        #get the text to save
        buff = self.builder.get_object("textview1").get_buffer()
        start_iter = buff.get_start_iter()
        end_iter = buff.get_end_iter()
        text = buff.get_text(start_iter,end_iter)

        #get all the records
        record_type = "http://wiki.ubuntu.com/Quickly/JottyDoc"
        results = self.database.get_records(record_type = record_type, 
                                            create_view = True)

        #update a record that has the same title
        for result in results:
            document = result.value
            if document["title"] == title:
                key = result.key
                self.database.update_fields(key, {"text":text})
                return
        
        #if no records had the title, create it  
        new_rec = Record({"record_type":record_type ,
                            "title":title, "text":text})
        self.database.put_record(new_rec)

</TEXTAREA></DIV>

<P>Couchdb makes it really easy to see if your save function is working. You can just point your web browser at it and explore the database:</P>
<DIV><A HREF="file:///home/your_user_name>/.local/share/desktop-couch/couchdb.html">file:///home/rick/.local/share/desktop-couch/couchdb.html</A></DIV>
<IMG SRC="./images/couch1.png" ALT="open couchdb in a browser" />
<P>If you are redirected to a page that doesn't work, you probably just need to clear your browser cache and try again.</P>

<H3>Implementing Open and New</H3>
<P>To open a saved document, the user will type the title of the document that they want to open in the text entry, and choose "Open" from the main menu. If there is no matching document there, it will just clear out the text view, ready for input. This is probably not too intuitive, so we'll add a dialog box for prompting the user for the title, but that's for later in the tutorial. For now, we'll just use the same text entry field.</P>

<H4>Implementing Open is essentially the reverse of Save:</H4>
<P>Follow these steps:</P>
<OL>
<LI>Add the open_file signal to the menu item in Glade.</LI>
<LI>Retrieve all of the documents with the CouchDatabase.get_records function.</LI>
<LI>Check each of the returned records for a matching title.</LI>
<LI>If there is a match, pull out the text and display it in the text view.</LI>
</OL>

<P>So the open_file function looks like so:</P>
<DIV class="code"><TEXTAREA rows="20" cols="80">
    def open_file(self, widget, data=None):
        #get the name of the document to open
        title = self.builder.get_object("entry1").get_text()
        text = ""

        #get all the records
        record_type = "http://wiki.ubuntu.com/Quickly/JottyDoc"
        results = self.database.get_records(record_type = record_type, 
                                            create_view = True)

        #get the text if there is a matching title
        for result in results:
            document = result.value
            if document["title"] == title:
                text = document["text"]
        
        #set the UI to display the string
        buff = self.builder.get_object("textview1").get_buffer()
        buff.set_text(text)
</TEXTAREA></DIV>

<H4>Implement New</H4>
<P>First, add the new_file signal to the menu item in Glade, then add this code to clear out the text:</P>
<DIV class="code"><TEXTAREA rows="4" cols="80">
    def new_file(self, widget, data=None):
        self.builder.get_object("entry1").set_text("Note Title")
        buff = self.builder.get_object("textview1").get_buffer()
        buff.set_text("")
</TEXTAREA rows="20" cols="80"></DIV>

<P>To make them work, add these functions to the JottyWindow class, and save. Then go back and connect the functions to the activate signals for the Open and New menu items.</P>

<DIV class="ref_link">
<A HREF="./code/jotty">Complete jotty file</A>
</DIV>

<H1>Saving Your Work</H1>
<P>When Quickly created your application, it automatically added it to Bazaar, a source code versioning system. You can use Bazaar to roll back mistake, see code history, compare versions, etc... Quickly has a convenience function for backing up your work:</P>
<DIV class="termina"><TEXTAREA rows="1" cols="80">
$ quickly save "First working version of Jotty"
</TEXTAREA></DIV>
<P>This will call "$ bzr add" and then "$ bzr commit -m [your message]" for you.</P>

</BODY>
</HTML>
