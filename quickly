#!/usr/bin/env python
# -*- coding: utf-8 -*-

import os
import sys
import subprocess
import gettext
from gettext import gettext as _

from builtins import commands, configurationhandler, tools, launchpadaccess

def usage():
    print _("""Usage:
    quickly [OPTIONS] command ...
    
Options:
    -t, --template <template>  Template to use if it differs from default
                               project one
                               one used to create the project)
    --staging                  Target launchpad staging server
    --verbose                  Verbose mode
    -h, --help                 Show help information

Commands:
    new <template> <project-name> (template is mandatory for this command)
    quickly <template_origin> <template_dest> to create a new derived template
    start to get some starting hints

Examples:
    quickly new ubuntu-project foobar
    quickly push 'awesome new comment system'
    quickly -t cool-template push 'awesome new comment system'""")

def look_for_commands(template_path=None):
    """ seek for available commands

TEMPLATE directâ€¦
    template_path: where templates are located. None if we want to list all commands for all templates.

    : return tuples with list of available commands and origin (default or template)
    """

    if template_path is not None:
        print _("in progress")


def check_this_command(command_name, template_path, opt_template):
    """ check if the command exist in a template

            For instance, for a command like foo, the inside template foo.py script
            file is preferred to built-in foo() function.
            There can be pre_foo() and post_foo() built-in functions.

            :command_name
            :template_path

            return list of commands ready to be launched
    """

    commands_available = {}

    # check for template command
    command_path = template_path + "/" + command_name + ".py"
    if os.path.exists(command_path):
        commands_available[opt_template] = command_path
    else:
        #check for built-in command
        if hasattr(commands, command_name):
            commands_available[opt_template] = getattr(commands, command_name)
        else:
            print _("ERROR: command '%s' in '%s' not found.") % (command_name, opt_template)
            print _("Aborting")
            exit(1)        

    #check for pre-post built-in commands
    for hook in ("pre", "post"):
        if hasattr(commands, hook + '_' + command_name):
            commands_available[hook] = getattr(commands, hook + '_' + command_name)

    return commands_available


def process_command_line():
    """ Entry point for command line processing

    :return: exit code of quickly command.
    """
    if len(sys.argv) == 1:
        usage()
        return 0

    opt_command = []
    out_off_project_tree_command = False
    opt_has_template = False
    need_template = True
    argv = sys.argv
    i = 1

    while i < len(argv):
        arg = argv[i]
        if arg == '--template' or arg == '-t':
            opt_has_template = True
            opt_template = argv[i + 1]
            i += 1
        elif arg == '--staging':
            oldenv = ""
            if os.environ.has_key('QUICKLY'):
                oldenv = os.environ['QUICKLY']
            os.environ['QUICKLY'] = "staging " + oldenv
        elif arg == '--verbose':
            oldenv = ""
            if os.environ.has_key('QUICKLY'):
                oldenv = os.environ['QUICKLY']
            os.environ['QUICKLY'] = "verbose " + oldenv
        elif arg == '--help' or arg == '-h':
            usage()
            return 0
        else:
            if arg == 'new' or arg == 'quickly':
                out_off_project_tree_command = True
            elif arg == 'start':
                out_off_project_tree_command = True
                need_template = False
            opt_command.append(arg)
        i += 1

    # ensure the command exists
    if not opt_command:
        print _("ERROR: No command found")
        print _("Aborting")
        usage()
        return 1

    # get the template if needed
    if need_template:
        # if processing a "out_off_project_tree_command", template argument
        # and project name must be there (with -t, --template or just following the command): new, quickly
        if out_off_project_tree_command:
            if not opt_has_template:
                if len(opt_command) < 3 or opt_command[1].startswith('-'):
                    print _("ERROR: %s command must be followed by a template and destination name" % opt_command[0])
                    print _("Aborting")
                    usage()
                    return 1
                else:
                    opt_template = opt_command[1]
                    opt_command.remove(opt_command[1])
                    opt_has_template = True

            #in every cases, the project name is now in first position.
            project_name = opt_command[1]
            project_dir = os.path.abspath(os.getcwd() + '/' + project_name)

        # the config file already exist, get project path and load configuration.
        else:
            try:
                project_dir = tools.get_root_project_path()
            except tools.project_path_not_found:
                print _("ERROR: Can't find project in %s.\nEnsure you launch this command from a quickly project directory.") % os.getcwd()
                sys.exit(1)        
            configurationhandler.loadConfig()

        #if no template provided, guess it from the current tree
        if not opt_has_template and need_template:
            try:
                opt_template = configurationhandler.config['template']
            except KeyError:
                print _("ERROR: No template provided and none found in the current tree. Ensure you " \
                            "don't want to create a new project or that your are in your directory project.")
                print _("Aborting")
                return 1

        # get the template path
        template_path = tools.get_template_directory(opt_template)   

    # no template needed, empty them
    else:
        template_path = ''
        opt_template = ''
        project_dir = ''


    # execute the command
    commands_to_execute = check_this_command(opt_command[0], template_path, opt_template)
    return_code = 0
    # pre-hook
    if 'pre' in commands_to_execute:
        return_code = commands_to_execute['pre'](opt_template, project_dir, opt_command[1:])
    if return_code != 0:
        print _("ERROR: pre_%s command failed") % opt_command[0]
        print _("Aborting")
        return return_code

    # main execution
    if callable(commands_to_execute[opt_template]):
        return_code = commands_to_execute[opt_template](opt_template, project_dir, opt_command[1:])
    else:
        return_code = subprocess.call(["python", commands_to_execute[opt_template]] + opt_command[1:], cwd=project_dir)

    if return_code != 0:
        print _("ERROR: %s command failed") % opt_command[0]
        print _("Aborting")
        return return_code

    # post-hook
    if 'post' in commands_to_execute:
         commands_to_execute['post'](opt_template, project_dir, opt_command[1:])
    if return_code != 0:
        print _("ERROR: post_%s command failed") % opt_command[0]
        print _("Aborting")
        return return_code

    return 0

if __name__ == '__main__':

    gettext.textdomain('quickly')

    # process the command line to send the right instructions
    exit(process_command_line())
