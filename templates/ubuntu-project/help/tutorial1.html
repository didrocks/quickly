<HTML>
<HEAD>
<TITLE>Quickly Tutorial Part 1</TITLE>
</HEAD>
<BODY>
<H1>Introduction to Part 1</H1>
This part 1 of th Quickly tutorial. This part is will introduce some key quickly commands, editing a user interface in Glade, and editing code in Gedit. This part of the tutorial will familiarize you with these three tools, and how they work together with python and pygtk so that you can quickly build applications.

<H2>Other Parts</H2>
making a package
releasing
adding a toolbar
adding a dialogbox or window
creating and reusing a custom widget
saving user preferences
quickly reference

<H1>Creating a Quickly Project</H1>
<H2>Creating the Empty Project</H2>
Creating an empty but working program couldn't be simpler. First, open a terminal window to type commands into. When it's open, type the command:
<DIV class="termnial">
$quickly new ubuntu-project super_text
</DIV>
<IMG SRC="./images/terminal1.png" ALT="type 'quickly new ubuntu-project super_text' into terminal" />
This will create a super_text sub directory containing a complete directory tree and files for an empty python appliction. The command finishes by running the newly created empty application.
<IMG SRC="./images/application1.png" ALT="The command finishes by running the empty application." />

<H2>Testing the Empty Application</H2>
The are populated and set up, and you can resize the window. Notice that quickly interfered that the application title is "Super Text". Only a few of menu items do anything in the empty application, Help->About, Edit->Preferences, and File->Quit.
<IMG SRC="./images/application2.png" ALT="The menus are populated and set up." />

<H2>Running the Application</H2>
Close the application by closing the window or using the Quit command. Since the empty application isn't installed into Ubuntu yet, you can't start the application from the application menu yet. To start the applicaton, use the terminal to first cd into the new subdirectory, and then issue the command to start the program.
<DIV class="termnial">
$cd super_text
super_text$./super_text
</DIV>
<IMG SRC="./images/terminal3.png" ALT="run the empty application from the terminal" />

<H1>Editing an Application</H1>
<H2>Edit the User Interface in Glade</H2>
Quickly programs use Glade to edit the user interface. Start Glade with quickly in order to set up Glade for editing the empty applicaton. Don't start glade directly, or it won't load the necessary catalogue files for editing the classes that were automaticaly generated by quickly.
<DIV class="termnial">
super_text$quickly glade
</DIV>
<IMG SRC="./images/terminal4.png" ALT="start glade with the 'quickly glade' command " />
Glade will open with the project loaded up and ready to edit.
<IMG SRC="./images/glade1.png" ALT="glade loads the project " />
Use the Project Menu to choose "SuperTextWindow.ui" for editing.
<IMG SRC="./images/glade2.png" ALT="choose SuperTextWindow.ui from the project menu " />
We want to create a text area for typing into. There are some default Widgets added to the Window. We won't need these so we'll start with deleting them. Click on the label, and press delete, and it will disappear from the window.
<IMG SRC="./images/glade3.png" ALT="select the label" />

<IMG SRC="./images/glade4.png" ALT="delete the label from the window" />
Do the same with the image widget.
<IMG SRC="./images/glade4.png" ALT="select the image" />
<IMG SRC="./images/glade5.png" ALT="delete the image from the window" />
This leave us two free slots.
<IMG SRC="./images/glade6.png" ALT="two empty slots in the window" />
We'll use the bottom slot to add a TextView widget for the user to type into. In the toolbox, click on the TextView widget. Then click in the empty slot.
<IMG SRC="./images/glade7.png" ALT="click on the text view widget" />
<IMG SRC="./images/glade6.png" ALT="click in the empty slot" />
Make sure you save the file in Glade, or your changes won't take! Then run the application from terminal again. The window now has a place where the user can type.
<IMG SRC="./images/application3.png" ALT="the applicaton permits typing" />

<H2>Add the Save, Open, and New Features</H2>
After the user types something, they may want to save it. A File->Save menu item was automatically created in the empty was created, but it's not hooked up to any code. To make Save work, we need tell the menu item what function to call, and then create a funtion to actually do the saving.

<H3>Set the Signal Handler in Glade</H3>
To tell the menu item what function to call, open up the window in glade:
<DIV class="termnial">
super_text$quickly glade
</DIV>
Click on the file menu, and the menu opens as if the application were running.
<IMG SRC="./images/glade7.png" ALT="choose the menu item" />

Choose the Save menu item, and it will be selected in Glade.
<IMG SRC="./images/glade8.png" ALT="the menu item is selcted in glade" />

Then choose the "Signals" tab of the properties window.
<IMG SRC="./images/glade8.png" ALT="signals tab in glade" />
In pygtk, menu items are "activated" when a user chooses the item from the menu.  Since we want a function to run when the user chooses Save, we want to specify a function to respond to the activate signal from the menu item. We'll call the function "save_file". Simply type the function name into the box for the activate signal. Make sure to save the glade file.
<IMG SRC="./images/glade9.png" ALT="activate signal set to 'save_file'" />

<H2>Edit the Code in Gedit</H2>
<H3>Create the Save File Signal Handler</H3>
Of course, this won't make the file actually save, because we haven't created the "save_file" function yet. So it's time to write a little code.

The code for SuperTextWindow is stored in the file SuperTextWindow.py. 
<DIV class="note">
Notice the relationship, SuperTextWindow.ui and SuperTextWindow.py. These two files always work tog.ether to make your program work. The .ui file stores the presentation of the window, while the .py file stores the behavior.
</DIV>

Use the quickly edit command to start editing your code files:
<DIV class="termnial">
super_text$quickly edit
</DIV>
This will open the default Ubuntu text editor "Gedit" with any python files in the python directory. In this case, just SuperTextWindow.py and about.py.
<IMG SRC="./images/gedit1.png" ALT="python files ready to edit" />

SuperTextWindow.ui is now expecting to find a function SuperTextWindow.save_file(), so we simply add one to the SuperTextWindow class:
<DIV class="code">
 def save_file(self, widget, data=None):
    print "save"
</DIV>
This will print the word "save" to the terminal when run. The method signature is the standard signature expected in a signal handler. If you are new to python, be sure to copy the indentations exactly, as the indentation level is very important in python.
<IMG SRC="./images/gedit2.png" ALT="the save command" />
Save the file, and run it again:
<DIV class="termnial">
$cd super_text
super_text$./super_text
</DIV>
Choose "File->Save" from the menu, and you'll see the word "save" printing out interminal. That's all there is to hookig up the functions!
<IMG SRC="./images/application1.png" ALT="The command finishes by running the empty application." />

<H3>Implementing Save</H3>
Now we'll write a little code in the signal handler to actually save the file. The code will do the following:
<OL>
<LI>Open the standard save dialog box from Ubuntu to get the file location.</LI>
<LI>Check if the user chose "Save" or "Cancel".</LI>
<LI>Get the filepath from the Save Dialog</LI>
<LI>Retrieve the text from the TextView</LI>
<LI>Write the file to disk at the specified location.</LI>
</OL>

<H4>Here's the code to create the file dialog:</H4>
pygtk has a file dialog that can be used for selecting files and folders for operations like saving and opening files. We need to do a little setup to configure it for saving a file, like setting the title, and creating a set of buttons that include associated responses. The stock Cancel/Save butons and stock Cancel/Ok responses work well for this.
<DIV class="code">
    #Create the save file dialog
    title = "Choose a File Location"
    buttons=(gtk.STOCK_CANCEL, gtk.RESPONSE_CANCEL, gtk.STOCK_SAVE, gtk.RESPONSE_OK)
    chooser = gtk.FileChooserDialog(title=title, parent=self, buttons=buttons,action=gtk.FILE_CHOOSER_ACTION_SAVE)
</DIV>

<H4>Here's the code to run the dialog, check if the user chose Save or Cancel, and get the path the user chose:</H4>
In pygtk, dialogs have a "run" function which displays the dialog. When the function returns, you should check the result to decide how to proceed. You also need to destroy the dilalog, or it won't get out of the user's way! Since we associated gtk.RESPONSE_OK with the Save button, we'll only set a file_path if the user chose Save. If file_path is set to nothing, then we'll just return from the function without doing anything else.
<DIV class="code">
    #run the dialog and get the path name
    file_path = None
    if chooser.run() == gtk.RESPONSE_OK:
        file_path = chooser.get_filename()
    chooser.destroy()

    #if there's no file_path, we're done      
    if file_path == None:
        return
</DIV>

<H4>Here's the code to get pull the text out of the TextView:</H4>
In pygtk, TextView widgets have a text buffer that stores the text. So you ask the TextView for it's TextBuffer, and then you ask the TextBuffer for the text. You use iters to determine from which part of the text buffer you want text. Since we want all the text, it's easy to just get the start and end iters.
<DIV class="code">
    #get the string
    buff = self.builder.get_object("textview1").get_buffer()
    start_iter = buff.get_start_iter()
    end_iter = buff.get_end_iter()

    text = buff.get_text(start_iter,end_iter)
</DIV>

Here's the code to write the file:
Writing text files in Python is easy. You just use the "open" function, telling it what file to open, and the mode, in this case 'w' for "write". If the specified file does not exist, Python will simply create it for. Write the text and close the file.
<DIV class="code">
    #save the file
    f = open(file_path,'w')
    f.write(text)
    f.flush()
    f.close()
</DIV>

<H4>So the whole function should look like this:</H4>
<DIV class="code">
    def save_file(self, widget, data=None):
        #Create the save file dialog
        title = "Choose a File Location"
        buttons=(gtk.STOCK_CANCEL, gtk.RESPONSE_CANCEL, gtk.STOCK_SAVE, gtk.RESPONSE_OK)
        chooser = gtk.FileChooserDialog(title="Save File", parent=self, buttons=buttons,action=gtk.FILE_CHOOSER_ACTION_SAVE)

        #run the dialog and get the path name
        file_path = None
        if chooser.run() == gtk.RESPONSE_OK:
            file_path = chooser.get_filename()
        chooser.destroy()

        #if there's no file_path, we're done      
        if file_path == None:
            return
    
        #get the string
        buff = self.builder.get_object("textview1").get_buffer()
        start_iter = buff.get_start_iter()
        end_iter = buff.get_end_iter()

        text = buff.get_text(start_iter,end_iter)

        #save the file
        f = open(file_path,'w')
        f.write(text)
        f.flush()
        f.close()
</DIV>

<H3>Implementing Open and New</H3>
<H4>Implementing Open is essentially the reverse of Save:</H4>
Follow these steps:
<OL>
<LI>Open the standard open dialog box from Ubuntu to get the file location.</LI>
<LI>Check if the user chose "Open" or "Cancel".</LI>
<LI>Get the filepath from the Open Dialog.</LI>
<LI>Retrieve the text from the file.</LI>
<LI>Put the text from the file into the TextView.</LI>
</OL>
So the open_file function looks like so:
<DIV class="code">
    def open_file(self, widget, data=None):
        #Create the open file dialog
        title = "Choose a File To Open"
        buttons=(gtk.STOCK_CANCEL, gtk.RESPONSE_CANCEL, gtk.STOCK_OPEN, gtk.RESPONSE_OK)
        chooser = gtk.FileChooserDialog(title=title, parent=self, buttons=buttons,action=gtk.FILE_CHOOSER_ACTION_SAVE)
    
        #run the dialog and get the path name
        file_path = None
        if chooser.run() == gtk.RESPONSE_OK:
            file_path = chooser.get_filename()
        chooser.destroy()

        #if there's no file_path, we're done      
        if file_path == None:
            return

        #read int he file the file
        f = open(file_path,'r')
        text = f.read()

        #set the buffer to display the string
        buff = self.builder.get_object("textview1").get_buffer()
        buff.set_text(text)

    </DIV>
<H4>To implement New, we'll just clear out the text, like this:</H4>
<DIV class="code">
    def new_file(self, widget, data = None):
        buff = self.builder.get_object("textview1").get_buffer()
        buff.set_text("")
</DIV>

To make them work, add these functions to the SuperTextWindow class, and save. Then go back and connect the functions to the activate signals for the Open and New menu items.

<DIV class="ref_link">
<A HREF="./code/SuperTextWindow_complete.py">Complete SuperTextWindow.py file</A>
</DIV>


</BODY>
</HTML>
